# mysql_shard Пакет для масштабирования MySQL

## Введение

**Шардинг** - метод распределения одной большой логической таблицы на множество небольших физических таблиц. Упрощенный аналог шардинга - тип таблиц CONFEDERATED.

**Стратегия шардинга** - алгоритм расппределения записей по разным физическим таблицам

**шарда** - Таблица или БД для записи данных

**Критерий шардинга** - это функция или правило, на основании которого принимают решение к отнесению записи в ту или иную таблицу расшарженной БД (шарду) 


#Требования

Для реализации пакета необходим:
- MySQL 5.0 или выше
- Redis 2.0 или выше

Redis используется, как персистентное быстрое хранилище одной ячейки ключ-значение. Использование Redis не принципиально и выбрано как наиболее популярное решение, но если вы в своих проектах используете MemcacheDb, Tarantool, AeroSpike или другие Key/Value NoSQL решения - то можете использовать и их. Присылайте свои pull-request и мы интегрируем ваш код для более нашего Сообщества.


##Стратегии шардинга

В данном пакете реализованы три алгоритмя шардиннга
- Линейный
- Циклический
- Помесячный
- Географический (не реализовано, но в плане)

##Линейный шардинг

**Линейный шардинг** -  алгоритм при котором записи распределяются линейно, сперва заполняется таблица №1, затем таблица №2 и т.д.

Распределение таблиц по БД определяется в конфигурационном файле, папка config, файл [sharding.php](https://github.com/akalend/mysql_shard/blob/master/configs/sharding.php) 

Например, в данной конфигурации:
```php
	[
	'instance' => [
	    [
	        'host' => '127.0.0.1',
	        'port' => 3306,
	        'db' => [
	            'lines' => [0,1,4],
	            'months' => [0,1],
	        ],
	    ],
	    ,
        [
            'host' => '127.0.0.1',
            'port' => 3307,
            'db' => [
                'lines' => [2,3],
                'months' => [2,3],
            ],
    ]
```

Используется дла экземпляра MySQL, один запущен на порту 3306, второй 3307. 
Первый экземпляр содержит следующие БД(127.0.0.1:3306):
	- lines_0
	- lines_1
	- lines_4
	- month_0
	- month_1

Второй экземпляр MySQL (127.0.0.1:3307):
	- lines_2
	- lines_3	
	- month_2
	- month_3


В примерах и тестах для линейного шардинга используется БД lines_*, соответственно первоночально будет заполняться таблицы в БД lines_0 и lines_1 на первом сервере, затем lines_2 и lines_3 на сервере 2, затем lines_4 и вновь в БД lines_0 на сервере 1, далее в lines_2 и lines_3  и так по кругу...


##Циклический шардинг

**Циклический шардинг** -  алгоритм при котором записи распределяются по кругу, сперва пишется записб втаблицу №1, затем таблица №2 и т.д. до таблицы N, и далее вновь в таблицу №1, затем таблица №2 и т.д по кругу. 

Вычисление номера таблицы определяется по формуле:

	TabN = RecNo % N

где
- RecNo номер записи
- N      кол-во таблиц (шард) для записи


##Помесячный шардинг

Аналогичен циклическому, только записи производится в таблицу одного месяца. Т.е. тут присутствуют два критерия шардинга - это некий номер (id) и дата. В данном примере могут использоваться табл: stats_2016_06,stats_2016_07,stats_2016_08 для данных за июнь,июль,август 2016, а вот сами данные пользователей будут распреледяться по базам по алгоритму циклического шардинга.


##Географический шардинг (не реализованно)

**Географический шардинг** -  алгоритм при котором записи распределяются в соответствии конфига, например в таблице geo_msk лежат данные для Москвы, geo_spb - Петербурга, geo_nsb - Новосибирска, geo_nng - Нижний Новгород.


##Пример

Пусть собирается некоторая информация в "бесконечный"" лог файл. Для этого реализуем стратегию линейного шардинга:
```php
	// некоторая мифическая функция получения абстрактных данных
	$data = get_some_data();

	// загрузка конфигурационного файла
	$conf = Config::get('sharding');

	// создание экземпляра MysqlShard($conf)
    $sharding = new MysqlShard($conf);

	// создание экземпляра стратегии
    $strategy = new LinearStrategy(null,'lines', $sharding->getConfig());
    
    //шаблон запроса
    $sql = "INSERT INTO %db.logdata_%t (data) VALUES('$data')";

    //выполнение запроса
    $sharding->query($sql);
```

##Структура, Шаблоны запросов

**Класс MysqlShard**  создает среду для выполнения запрососв, на основе конфигурационного файла и выполняют запрос в соответствии с заданной стратегией на соответствующий сервер. 

**Класс Cтратегия** вычисляет номер таблицы и БД в соответствии с заданным алгоритмом, и отдает необходимые данные для выполнеия запроса. 

Так как наш код отгораживает пользователя от вычисления имен таблиц и баз, то мы должны это дело вычислить и подставить автоматически. По  этому вводятся мнемонические имена, как на подобие команды fprint, вместо данного символа вставляется:
- %db  имя и номер базы данных
- %t   имя и номер таблицы в БД

так в данном примере для используемого нами конфигурационного файла для
- первой записи, будет сгенерирован  SQL: INSERT INTO lines_0.logdata_0 (data) VALUES('some data')
- для 100 000 001 записи   : INSERT INTO lines_1.logdata_1 (data) VALUES('some data') (при условии, что установлено максимальное число записей в одну таблицу будет 100 000 000 записей)


Чтение записи:
```php
	<?php
		
		// загрузка конфигурационного файла
		$conf = Config::get('sharding');

		// создание экземпляра MysqlShard($conf)
        $sharding = new MysqlShard($conf);

		// создание экземпляра стратегии $id = номеру записи
        $strategy = new LinearStrategy($id,'lines', $sharding->getConfig());
        
        //шаблон запроса
        $sql = "SELECT * FROM %db.logdata_%t WHERE id=$id";

        //выполнение запроса
        $res = $sharding->query($sql);
        $row = $res->fetch_assoc();
        var_dump($row);
```

Класс Cтратегия сам вычислит номер таблицы и БД, а класс MySQLShard законектится на соответствующий сервер и выполнит запрос.

##Еще Пример

Пусть мы записываем некоторую статистическую информацию, привязанную к датам и будем хранить её в базах months. Для этого нам удобнее всего  реализовать помесячную стратегию шардинга. Не актуальные данные легко архивировать, переносить или просто уничтожить, не подвергая нагрузки всю систему в целом.

```php
	<?php 
		
		// загрузка конфигурационного файла
		$conf = Config::get('sharding');

		// создание экземпляра MysqlShard($conf)
        $sharding = new MysqlShard($conf);


		$date = date('Y-m'); // устанавливаем дату

		// создание экземпляра стратегии, устанавливаем $user_id = номер клиента
        $strategy = new MonthStrategy($user_id,'months', $sharding->getConfig(), $date);
        
        $sql = "INSERT INTO %db.stats_%t (data) VALUES('$data')";

        //выполнение запроса
        $res = $sharding->query($sql);
```

 В данном примере для user_id вычисляется номер БД, например для $user_id=100, номер БД будет 100 % 4 = 0, т.е. БД months_0, которая лежит на первом экземпляре MySQL сервера (порт 3306), а для даты '10-06-2016' сгенерируется таблица: stats_2016_06, куда и будут записаны данные. 

 Следует отметить, что при использовании Циклической или Помесячной стратегии - на разных шардах могут лежать таблицы с одинаковыми именами, чего не может быть, при использовании линейной стратегии.

##Пример обхода всех шард

```php 
<?php 		

    $sharding = new MysqlShard(Config::get('sharding'));
    $strategy = new MonthStrategy(null,'months', $sharding->getConfig(),  date('Y-m'));

   // некоторый запрос, для всех шард для для таблиц stats_YYYY_MM
    $sql = "SELECT FROM %db.stats_%t (data) WHERE type_id=$x";

    $rows = [];
    foreach ($sharding as $shrdItem) {
    	//выполнение запроса
    	$res = $sharItem->query($sql);
    	while( $row = $res->fetch_assoc()) {
    		$rows[] = $row;
    	}
    }

```



##БД main

БД *main* - это маленькая БД, в которой лежат текущие данные нашей конфигурации, можно указать любую существующую БД, в которой необходимо будет создасть таблицу state c полем  tab_id_%x, где %x - это имя конфига для Линейной стратегии. По сути - она дублирует данные, которые хранятся в Редисе. Да, к сожалению редис иногда бывает недоступен, с ошибкой: "Redis server went away", а наша система должна быть доступна с 99.9999%  иначе данные могут записаться не в ту шарду.

Если у нас используется две БД с линейным шардированием, то таблица state должна содержать два поля tab_id_%x. Например, если мы имеем конфигурационный файл с линейными стратегиями: profiles, messages, то таблица должна иметь следующую схему:
```sql
CREATE table state ( 
	tab_id_profiles INT, 
	tab_id_messages INT 
);

```


##Тестовое окружение

Для тестирования используется PHPUnit. Для тестового окружения (два экземпляра MySQL и Redis) использовал Docker. 

1. Создаем образ для MySQL: 

```bash
	docker pull mysql
	dockeer pull redis
```
2. Поднимаем образ на порту 3306 и 3307:

```bash
	docker run --name redis  -d redis

	docker run --name mysql  -e MYSQL_ROOT_PASSWORD=12345 -d -p 127.0.0.1:3306:3306  -e MYSQL_USER=akalend -e MYSQL_PASSWORD=12345   mysql
	docker run --name mysql2 -e MYSQL_ROOT_PASSWORD=12345 -d -p 127.0.0.1:3307:3306  -e MYSQL_USER=akalend -e MYSQL_PASSWORD=12345   mysql
```
Вы можете вместо akalend задать сой логин и свой пароль

3. Создаем тестовые БД:

```bash
	mysql -u akalend -P 3306 -p -h 127.0.0.1 < configs/create_1.sql
	mysql -u akalend -P 3306 -p -h 127.0.0.1

	mysql -u akalend -P 3307 -p -h 127.0.0.1 < configs/create_2.sql
```

5. В MySQL клиенте устанавливаем права

```SQL
	GRANT ALL PRIVILEGES ON *.* TO 'akalend'@'%' ;
	FLUSH PRIVILEGES;
```

6. Настроив контейнеры, их можно запускать и останавливать:

```bash
	docker start/stop redis
	docker start/stop mysql
	docker start/stop mysql2
```

Далее имем в папкe tests и запускаем тесты. Тесты статегий CycleStrategy & MonthStrategy осуществляются без записи в БД, 
LinearyStartegy осуществляет запись в БД, и проверяется на переключение шарды.


## Вопрос Ответ

- Примеров мало, а АПИ большой
- Большой АПИ для большей гшибкости, постараемся сделать примеров больше (нужно время)

-----
 
- Что делать при решардинге
- дописать класс стратегия, в котором будут определены условия выбора номера шарды до и после решардинга. Вообще - решардинг очень больной процесс, по этому за ранее думаем, как его избежать, или сделать наимее болезненным.
 
-----
 
- Нет нужной стратегии шардинга
- Напишите нам, мы добавим. В данном пакете те стратегии, которые используются в живом проекте. Ни чего не практического специально не изобреталось

-----
 
- Хотим изменить (увеличить/уменьшить) кол-во записей заполняемости таблицы в Линейной стратегии
- Да, пожайлуста, константа:  const MAX_RECORD_COUNT = 100000000; в классе LinearStrategy,  файл - src/strategy/linearstrategy.php

-----
 
- А что там еще за константа LIMIT_RECORDS = 100 ?
- Дело в том, что запросы на запись могут идти параллельно с разных WEB серверов, и пока идет переключение с шарды на шарду, то часть данных, принадлежащей одной шарде может попасть на её соседку. Чтоб этого не произошло, мы решили пареключить чуть раньше, как раз на LIMIT_RECORDS записей. В данном классе эта цифра завышена, Если у вас  максимальная скорость поступления данных для вставки, например, 30 запросов в сек, до на мой взгляд достаточно установить LIMIT_RECORDS = 40.

-----
 
- Хочу поучастволвать в разработке
- Всегда рады новым идеям, присылайте свои pull request и мы обязательно их включим  или добавим вас в контрибуторы


-----
 
- А мы используем PostgreSQL, как нам быть?
- Думаю тут понадобятся небольшие переделки, хотя в PostgreSQL есть кой-какие решения из коробки. Если не найдете подходящих решений, то пишите я допилю решение и под PostgreSQL. В нем есть ряд особенностей, например, в PostgreSQL нет AUTOINCREMENT полей, а в MySQL нет SEQUENCE. Но SEQUENCE может нам помочь решить проблему единого глобального счетчика, в настоящее время вместо него используется редис + БД main. Тут много существует интересных вариантов для реализации.

-----
 
- А тут как нибудь используется асинхронность?
- Пока нет, но планируется. В коде специально не используется PDO, чтоб можно было использовать асинхронность. Хорошо использовать асинхронность, если идет вставка или поиск данных одновременно по всем шардам. Этот вариант в настоящее время активно прорабатывается.


-----
 
- Как лучше создавать таблицы?
- Наиболее оптимальный способ создания таблиц - это использовать код из класса генераторов.  Для создания таблиц, реализующих линейный шардинг, применение генераторов настоятельно рекомендуется. Дело в том, что при создании таблицы, указывается её первый id-элемент, смотрим последнюю строку, обращаем внимание на **AUTO_INCREMENT=** :
```SQL
    CREATE TABLE `%%db`.`logs_%s` (
	  `id` bigint(20) NOT NULL AUTO_INCREMENT,
	  `inserted_ts` int(11) NOT NULL,
	  ...
	) ENGINE=InnoDB AUTO_INCREMENT=%d DEFAULT CHARSET=ascii;
```

Смотрим примеры создания таблиц: example2.php example4.php

-----
 

- А что делать, если таблицы для линейного шардинга стали заканчиваться?
- Написан крон-скрипт /src/tools/check_tables.php Его достаточно запускать раз в неделю/месяц (в соответствии со скоростью заполнения таблиц), который смотрит кол-во пустых таблиц, и если их осталось менее чем 2, то он генерит несколько новых пустых таблиц.


-----
 
- Планируется ли более полная документация?
- думаю, что и так много рассказал, теперь бы найти того, кто помог бы все это перевести для наших ангоязычных братьев. Единственное, что планируется - это создание Doxigen или phpdoc файла, для генерации документации по API.


-----
 
- Зачем нужен метод MysqlShard::setNoExec()
- Как уже упоминалось, для большей гибкости используется более широкое АПИ. Метод setNoExec класса MysqlShard позволяет нам пометить запрос как "не исполняемый", а далее методом getQuery() мы можем получить текст сгенерированного запроса. Очень удобно для отладки.

##Пример отладки

```php 
<?php 		

    $sharding = new MysqlShard(Config::get('sharding'));
    $strategy = new MonthStrategy(null,'months', $sharding->getConfig(),  date('Y-m'));

   // необходимо отладить некоторый запрос
    $sql = "SELECT FROM %db.stats_%t (data) WHERE type_id=$x";

    //отменяем выполнение запроса
	$sharding->setNoExec();

    foreach ($sharding as $shrdItem) {
    	$res = $sharItem->query($sql);

    	// выводи сформированный запрос
    	echo $shardItem->getQuery(),PHP_EOL;
    }
    // далее если необходимо восстанавливаем исполнение запросов
	$sharding->setNoExec(false);
```

